{"ast":null,"code":"import { stripe } from \"../../services/stripe\";\nimport { saveSubscription } from \"./_lib/manageSubscription\";\n\nasync function buffer(readable) {\n  const chunks = [];\n\n  for await (const chunk of readable) {\n    chunks.push(typeof chunk === \"string\" ? Buffer.from(chunk) : chunk);\n  }\n\n  return Buffer.concat(chunks);\n}\n\nexport const config = {\n  api: {\n    bodyParser: false\n  }\n};\nconst relevantEvents = new Set(['checkout.session.completed', 'customer.subscription.updated', 'customer.subscription.deleted']);\nexport default (async (req, res) => {\n  if (req.method === 'POST') {\n    const buf = await buffer(req);\n    const secret = req.headers['stripe-signature'];\n    let event;\n\n    try {\n      event = stripe.webhooks.constructEvent(buf, secret, process.env.STRIPE_WEBHOOK_SECRET);\n    } catch (err) {\n      return res.status(400).send(`Webhook error: ${err.message}`);\n    }\n\n    const {\n      type\n    } = event;\n\n    if (relevantEvents.has(type)) {\n      try {\n        switch (type) {\n          case 'customer.subscription.updated':\n          case 'customer.subscription.deleted':\n            const subscription = event.data.object;\n            await saveSubscription(subscription.id, subscription.customer.toString(), true);\n            break;\n\n          case 'checkout.session.completed':\n            const checkoutSession = event.data.object;\n            await saveSubscription(checkoutSession.subscription.toString(), checkoutSession.customer.toString());\n            break;\n\n          default:\n            throw new Error('Unhandled event.');\n        }\n      } catch (err) {\n        return res.json({\n          error: 'Webhook handler failed.'\n        });\n      }\n    }\n\n    res.json({\n      received: true\n    });\n  } else {\n    res.setHeader('Allow', 'POST');\n    res.status(405).end('Method not allowed');\n  }\n});","map":{"version":3,"sources":["/home/rodolfo/Documents/Estudo/Ignite/NextJS/Aulas/ignews/Ignite-Ig.News/src/pages/api/webhooks.ts"],"names":["stripe","saveSubscription","buffer","readable","chunks","chunk","push","Buffer","from","concat","config","api","bodyParser","relevantEvents","Set","req","res","method","buf","secret","headers","event","webhooks","constructEvent","process","env","STRIPE_WEBHOOK_SECRET","err","status","send","message","type","has","subscription","data","object","id","customer","toString","checkoutSession","Error","json","error","received","setHeader","end"],"mappings":"AAIA,SAASA,MAAT,QAAuB,uBAAvB;AACA,SAASC,gBAAT,QAAiC,2BAAjC;;AAEA,eAAeC,MAAf,CAAsBC,QAAtB,EAA0C;AACxC,QAAMC,MAAM,GAAG,EAAf;;AAEA,aAAW,MAAMC,KAAjB,IAA0BF,QAA1B,EAAoC;AAClCC,IAAAA,MAAM,CAACE,IAAP,CACE,OAAOD,KAAP,KAAiB,QAAjB,GAA4BE,MAAM,CAACC,IAAP,CAAYH,KAAZ,CAA5B,GAAiDA,KADnD;AAGD;;AAED,SAAOE,MAAM,CAACE,MAAP,CAAcL,MAAd,CAAP;AACD;;AAED,OAAO,MAAMM,MAAM,GAAG;AACpBC,EAAAA,GAAG,EAAE;AACHC,IAAAA,UAAU,EAAE;AADT;AADe,CAAf;AAMP,MAAMC,cAAc,GAAG,IAAIC,GAAJ,CAAQ,CAC7B,4BAD6B,EAE7B,+BAF6B,EAG7B,+BAH6B,CAAR,CAAvB;AAMA,gBAAe,OAAOC,GAAP,EAA4BC,GAA5B,KAAqD;AAElE,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,UAAMC,GAAG,GAAG,MAAMhB,MAAM,CAACa,GAAD,CAAxB;AACA,UAAMI,MAAM,GAAGJ,GAAG,CAACK,OAAJ,CAAY,kBAAZ,CAAf;AAEA,QAAIC,KAAJ;;AAEA,QAAI;AACFA,MAAAA,KAAK,GAAGrB,MAAM,CAACsB,QAAP,CAAgBC,cAAhB,CAA+BL,GAA/B,EAAoCC,MAApC,EAA4CK,OAAO,CAACC,GAAR,CAAYC,qBAAxD,CAAR;AAED,KAHD,CAGE,OAAOC,GAAP,EAAY;AACZ,aAAOX,GAAG,CAACY,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAsB,kBAAiBF,GAAG,CAACG,OAAQ,EAAnD,CAAP;AACD;;AAED,UAAM;AAAEC,MAAAA;AAAF,QAAWV,KAAjB;;AAEA,QAAIR,cAAc,CAACmB,GAAf,CAAmBD,IAAnB,CAAJ,EAA8B;AAC5B,UAAI;AACF,gBAAQA,IAAR;AACE,eAAK,+BAAL;AACA,eAAK,+BAAL;AAEE,kBAAME,YAAY,GAAGZ,KAAK,CAACa,IAAN,CAAWC,MAAhC;AAEA,kBAAMlC,gBAAgB,CACpBgC,YAAY,CAACG,EADO,EAEpBH,YAAY,CAACI,QAAb,CAAsBC,QAAtB,EAFoB,EAGpB,IAHoB,CAAtB;AAMA;;AACF,eAAK,4BAAL;AAEA,kBAAMC,eAAe,GAAGlB,KAAK,CAACa,IAAN,CAAWC,MAAnC;AAEA,kBAAMlC,gBAAgB,CACpBsC,eAAe,CAACN,YAAhB,CAA6BK,QAA7B,EADoB,EAEpBC,eAAe,CAACF,QAAhB,CAAyBC,QAAzB,EAFoB,CAAtB;AAKE;;AACF;AACE,kBAAM,IAAIE,KAAJ,CAAU,kBAAV,CAAN;AAxBJ;AA0BD,OA3BD,CA2BE,OAAOb,GAAP,EAAY;AACZ,eAAOX,GAAG,CAACyB,IAAJ,CAAS;AAAEC,UAAAA,KAAK,EAAE;AAAT,SAAT,CAAP;AACD;AACF;;AAED1B,IAAAA,GAAG,CAACyB,IAAJ,CAAS;AAAEE,MAAAA,QAAQ,EAAE;AAAZ,KAAT;AAED,GAlDD,MAkDO;AACL3B,IAAAA,GAAG,CAAC4B,SAAJ,CAAc,OAAd,EAAuB,MAAvB;AACA5B,IAAAA,GAAG,CAACY,MAAJ,CAAW,GAAX,EAAgBiB,GAAhB,CAAoB,oBAApB;AACD;AAEF,CAzDD","sourcesContent":["\nimport { NextApiRequest, NextApiResponse } from \"next\";\nimport { Readable } from 'stream'\nimport Stripe from \"stripe\";\nimport { stripe } from \"../../services/stripe\";\nimport { saveSubscription } from \"./_lib/manageSubscription\";\n\nasync function buffer(readable: Readable) {\n  const chunks = []\n\n  for await (const chunk of readable) {\n    chunks.push(\n      typeof chunk === \"string\" ? Buffer.from(chunk) : chunk\n    )\n  }\n  \n  return Buffer.concat(chunks)\n}\n\nexport const config = {\n  api: {\n    bodyParser: false\n  }\n}\n\nconst relevantEvents = new Set([\n  'checkout.session.completed',\n  'customer.subscription.updated',\n  'customer.subscription.deleted',\n])\n\nexport default async (req: NextApiRequest, res: NextApiResponse) => {\n\n  if (req.method === 'POST') {\n    const buf = await buffer(req)\n    const secret = req.headers['stripe-signature']\n\n    let event: Stripe.Event\n\n    try {\n      event = stripe.webhooks.constructEvent(buf, secret, process.env.STRIPE_WEBHOOK_SECRET)\n\n    } catch (err) {\n      return res.status(400).send(`Webhook error: ${err.message}`)\n    }\n\n    const { type } = event\n\n    if (relevantEvents.has(type)) {\n      try {\n        switch (type) {\n          case 'customer.subscription.updated':\n          case 'customer.subscription.deleted':\n\n            const subscription = event.data.object as Stripe.Subscription\n\n            await saveSubscription(\n              subscription.id,\n              subscription.customer.toString(),\n              true\n            )\n\n            break\n          case 'checkout.session.completed':\n\n          const checkoutSession = event.data.object as Stripe.Checkout.Session\n\n          await saveSubscription(\n            checkoutSession.subscription.toString(),\n            checkoutSession.customer.toString(),\n          )\n\n            break\n          default:\n            throw new Error('Unhandled event.')\n        }\n      } catch (err) {\n        return res.json({ error: 'Webhook handler failed.' })\n      }\n    }\n\n    res.json({ received: true })\n\n  } else {\n    res.setHeader('Allow', 'POST')\n    res.status(405).end('Method not allowed')\n  }\n\n}"]},"metadata":{},"sourceType":"module"}